= About Adding Operations
:toc: macro
:toclevels: 3
:toc-title:


toc::[]


== Declaring Operations

Operations are declared in a similar way as configurations, with the additional restriction that a class that has been annotated to serve as one configuration *cannot* contain its own configurations. Use the `@Operations` annotation to point to a class which holds the operations.


* Every _public_ method of the `@Operations` class is assumed to be a valid operation, therefore there is no need to use any annotation.
* Any public method you do not want exposed as an operation should be annotated with `@Ignore`
* Every method argument is translated as a `ParameterModel`
//MG need to mention ParameterModel? What does this model allow Extensions API to do?
* Arguments of each operation (`@Operations` class method) can be annotated with `@Optional` and with `@Expression`


See how you can declare available operations from the `@Extension` annotated class.

[source,java,linenums]
----
@Extension(name = "my-extension", description = my very own Mule extension”)
@Operations({MyOperations.class, NeatOperation.class})
public class MyExtension
{
}
----


== Configuration Level Operations

Operations may be defined at the configuration level by simply placing the `@Operations` annotation on a configuration class.


[source,java,linenums]
----
@Extension(name = "myextension", description = "my very own extension")
@Configurations({ImportantConfig.class, AnotherImportantConfig.class})
public interface MyExtension
{
}


@Configuration(name = "important")
@Operations(ImportantOperations.class)
public class ImportantConfig implements MyExtension
{
}


@Configuration(name = "another-important")
@Operations(OtherImportantOperations.class)
public class AnotherImportantConfig implements MyExtension
{
}
----

== Strategies for Implementing Operations

Below you can find some details about how to implement operations.

=== Injecting @UseConfig into an Operation

An operation can access a `@Configuration` class at runtime if any of the operation's arguments are annotated with `@UseConfig`. This injection allows operation access to the configuration when executed, that is, dynamically. See this link:https://github.com/mulesoft/mule/blob/82934f04daabd257c06521751a159b532d7fdbe3/modules/extensions-support/src/test/java/org/mule/module/extension/HeisenbergOperations.java#L69-L69[example].

In the examples above you can see operations which don’t require configuration data, while others do. Those operations implement part of their logic by having an argument annotated with `@UseConfig`.

The reason why you might choose to receive the configuration as a method argument becomes clearer in the *operations lifecycle* section. Note that:

* If the operation receives many arguments, there is no restriction on the position of the argument supporting configuration injection.
* There is no restriction or enforcement regarding the type of the configuration passed as an argument, as long as the type is the same as the configuration
* The argument will _not_ be translated into a `ParameterModel`

=== Operations that Return One Value

An operation can return a single value of any type.

Example:

[source,java,linenums]
----
public String toUpperCase(String value) {
	return value.toUpperCase();
}
----

This operation is adapted into a `MessageProcessor`, which returns a copy of the input message, whose _payload_ has been set to the method's _return value_.

=== Operations that Set Payload and Attributes

When the *payload* and the *attributes* of message must be manipulated and returned by the operation, return an `OperationResult`.

[source,java,linenums]
----
public OperationResult<InputStream, FileAttributes> read(String path) {
	return ...
}
----

`OperationResult` is defined link:https://github.com/mulesoft/mule-extensions-api/blob/1458edadff5d165503b4bf2b11b29eae07ac1cbd/mule-extensions-api/src/main/java/org/mule/runtime/extension/api/runtime/operation/OperationResult.java#L32-L32[here].

This object can return a *payload*, an *attributes object* and a `DataType`. The Mule runtime takes this object and generates a new Mule message, which is then propagated through the pipeline.
//MG: pipeline?

Although the object permits returning a *payload*, an *attributes object* and a `DataType`, it doesn’t require the user to actually provide all three. If none are provided, then the value from the incoming `MuleMessage` will be used.

=== Operations that Return List of Messages

//MG placeholder for new section in spec

=== Void Operations (Not Changing Mule Message)

Void operations do not modify the Mule message in any way:

.Example
[source,java]
----
public void logger(String message) {
}
----

In this case the message that enters the message processor is unchanged after exiting it.

=== Operations Accessing MuleEvent and MuleMessage

In most cases you should avoid interacting with core Mule data such as the message and the event, however in some cases you may find accessing these objects useful.

In regard to operations, a class containing operation methods can have attributes of type `MuleEvent` or `MuleMessage`. The runtime automatically provides them upon invocation of the method.
//MG upon invoking the method they become available

.Example

[source,java,linenums]
----
public Object someOperation(MuleMessage message, String value) {
	…
}
----

=== Operations Setting the DataType

The `MuleMessage` has the concept of `DataType` to provide information about the Mule message payload format, specifically:

* Encoding
* MimeType

Information in the `DataType` is used by Mule transformers to perform automatic transformation. An operation should be able to change the output `DataType` two ways:

* the user should have the chance to cast the data type
* the operation explicitly transforms the data type

=== Operations Forcing a DataType

By annotating a method with `@DataTypeParameters`, the operation can add an `outputEncoding` and `outputMimeType` parameters, allowing the user to ensure the desired output data type when in the application XML code.

[source,java,linenums]
----
@DataTypeParameter
public String read(String path, ContentType contentType) {
	return read(path, contentType.getEncoding());
}
----

That annotation instructs the SDK to automatically add the `outputEncoding` and `outputMimeType` parameters:

[source,xml,linenums]
----
<file:read path="some/path" outputEncoding="UTF-8" outputMimeType="application/json" />
----

=== Operations Determining DataType

An operation on its own can determine the `DataType`.

The solution for this is to simply have an operation which returns a `MuleMessage` with a handcrafted `DataType`. Notice however that if the operation returns a custom DataType but the user forced values on the XSD, the user’s settings will take precedence over the operation’s code.

//MG nested processor implementation not yet final?


=== Paging Operations

Paging lets you avoid out-of-memory issues when processing a large quantity of records. Use SDK's `PagingProvider` interface to process records in chunks.

.Example implementation of paged operation
[source,java,linenums]
----
public PagingProvider<ConnectionImpl, Account> getPagedPersonalInfo(int fetchSize) {


 return new PagingProvider<ConnectionImpl, Account>() {


   @Override
   public List<Account> getPage(ConnectionImpl conn) {
     return conn.getAccounts(fetchSize);
   }


   @Override
   public Optional<Integer> getTotalResults(ConnectionImpl conn) {
     return conn.getTotalPagesForSize(fetchSize);
   }


   @Override
   public void close() throws IOException {
     conn.close()
   }
 };
}
----

[NOTE]
* `getPage()` returns the next "page" of items
* `getPage()` returns an empty list when there are no more items to process
* in some cases, it may not be desirable to retrieve the total quantity of results, in which case force the `getTotalResults()` method to return an `Optional.empty()` value
//MG: is Optional.empty() standard Java expression?

=== Non-Blocking Operations

Mule 4 has a brand new execution engine based on reactive streams. That means there’s top level support for non-blocking operations. By default, all operations are blocking. As you probably noticed, the semantics of all the operation examples we’ve seen above are inherently blocking: the runtime invokes a method and gets a value in response. And that’s fine, since in real life most operations will be blocking (there aren’t much non blocking API’s/protocols out there, APIs such as JMS and DB don’t support non blocking and chances are they never will).

One of the few protocols for which does support this is http. Being able to perform non blocking http request is key for scalability of gateway proxies. Any connector consuming a REST API can also benefit from this.

Let’s see how the SDK allows you to develop non-blocking operations looking at an overly simplified http request operation

public void request(String url, @Connection HttpClient client, @Content String body, CompletionCallback<InputStream, HttpAttributes> callback) {
 client.send(url, body, new HttpResponseCallback() {
   void onResponse(HttpResponse response) {
     callback.success(Result.builder().output(response.getBody())
                          .attributes(toAttributes(response))
                          .build());
   }

   void onError(Exception e) {
     callback.error(e);
   }
 });
}

Let’s dig into the example:

An operation becomes non blocking when it has an argument of type CompletionCallback
Just like configurations and connections, this argument is synthetic and won’t be visible to the user.
Unlike blocking operations, the return type is not specified through the method’s return type:
Non blocking operations always need to be specified through void methods
The return value is passed through the success(Result) method of the CompletionCallback
The declaration of the operation’s output type is done through the callback generics. Those generics are mandatory and cannot be skipped
Non Blocking operations should not throw exceptions. Any errors should be channeled through the error() method in the callback
Notice that in this example, the CompletionCallback is being consumed from between an HttpResponseCallback. This second callback is provided by an httpClient which supports asynchronous responses itself. As stated before, in order to do non blocking, you need to be consuming an API which allows that.

So the result of this code, is a non blocking operation which returns an InputStream as payload and a HttpAttributes object as message attributes.

=== Void operations

It’s also possible to have a void non blocking operation. The use case for that is an IO operation which doesn’t return anything, such as writing to a file:

public void write(String path, @Content byte[] bytes, CompletionCallback<Void, NullAttributes> callback) {
 ...
}

As you can see here, you can use void and NullAttributes to represent an operation which is void.


=== Obtaining a Configuration’s Name

SDK takes care of XML parsing automatically. The downside of it is that you lose some degree of control regarding which information you can actually obtain.

One particular case is obtaining the name that a config has been given on the XML. Obtaining such a name is useful for logging purposes or to give descriptive names to any threads that the config starts.

To do that, the `@ConfigName` annotation is available:

[source,java,linenums]
----
@ConfigName
private String configName;
----

That annotation can be used on fields of classes from which a config is derived. Has to be of type String and does not require setters.

== UI Configurations

The platform tooling requires rendering UIs for a user to configure extensions and their operations. As the platform goes, this tooling goes beyond Anypoint Studio. It is possible to enrich the ExtensionModel with generic, technology agnostic, hints about how should that UI be rendered.

=== @Placement

https://github.com/mulesoft/mule-extensions-api/blob/72d2ae3ec8d9d480bd4318ce6c0e84b18f866bc7/src/main/java/org/mule/extension/api/annotation/param/display/Placement.java#L26-L26

The Placement annotation can be used at a parameter level on configs, operations and sources. It allows to assign parameters to specific tabs and/or specify the order in which it should appear in the tooling. This not only allows for a more clear and descriptive UI, it also allows putting cohesive parameters together regardless of how/where they’re defined in the source code.

=== @DisplayName

Allows giving a parameter a UI name which is different from the model one. It can be applied to any parameter, at any level.

https://github.com/mulesoft/mule-extensions-api/blob/aa0ee5622ab258c159664cbfb9508f20e30f95c2/src/main/java/org/mule/extension/api/annotation/param/display/DisplayName.java#L30-L30

=== @Text

https://github.com/mulesoft/mule-extensions-api/blob/9bb020798dfb3936ff1245e086e70ac47faa3f8f/src/main/java/org/mule/extension/api/annotation/param/display/Text.java#L27-L27

Specifies that a parameter should be rendered as a multi line text box. It can be applied to any parameter, at any level.

=== @Password

https://github.com/mulesoft/mule-extensions-api/blob/9bb020798dfb3936ff1245e086e70ac47faa3f8f/src/main/java/org/mule/extension/api/annotation/param/display/Password.java#L27-L27

Specifies that a parameter represents a password and should be masked in the UI. It can be applied to any parameter, at any level.

=== @Summary

https://github.com/mulesoft/mule-extensions-api/blob/a839fead7f1a5d80c90e1e509930b5ace23bba1a/mule-extensions-api/src/main/java/org/mule/runtime/extension/api/annotation/param/display/Summary.java#L32

Allows a brief summary about the parameter describing its purpose. This annotation is meant to be used for the content of a tooltip which adds a short but meaningful explanation of the parameter.

=== @Example

https://github.com/mulesoft/mule-extensions-api/blob/0345b700213ab38351ef3803b682ec58a8aad908/mule-extensions-api/src/main/java/org/mule/runtime/extension/api/annotation/param/display/Example.java#L28

Allows giving an example of how the value of the parameter should look like.

== Dependency Injection

All configurations and operations support dependency injection at a field level using the @Inject annotation. Any object in the mule registry is a candidate for injection. If many candidates of the same type are available, then the @Named annotation or any @Qualifier can be applied.

[source,java,linenums]
----
@Extension(name = "heisenberg", description = "heisenberg extension")
public class HeisenbergExtension
{
@Inject
private ExtensionManager extensionManager;
}

public class HeisenbergOperations
{

   @Inject
   private ExtensionManager extensionManager;
}
----

== Testing Framework

Tests using extensions should extend the `MuleArtifactFunctionalTestCase` class. This specialization of the traditional `FunctionalTestCase` TCK component still requires the user to provide the path to configuration file(s) with your tests flows, component, etc., but also provides the following services:

* It automatically discovers, creates and registers all the Mule modules in the test classpath
* It generates all resources needed for such modules to function
* It executes the tests using a classloading isolation schema similar to the one that the runtime will use when actually running in production.
