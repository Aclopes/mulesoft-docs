= About Ways to Implement Operations
:toc: macro
:toclevels: 3
:toc-title:


toc::[]



== Configuration Level Operations

Operations may be defined at the configuration level by simply placing the `@Operations` annotation on a configuration class.


[source,java,linenums]
----
@Extension(name = "myextension", description = "my very own extension")
@Configurations({ImportantConfig.class, AnotherImportantConfig.class})
public interface MyExtension
{
}


@Configuration(name = "important")
@Operations(ImportantOperations.class)
public class ImportantConfig implements MyExtension
{
}


@Configuration(name = "another-important")
@Operations(OtherImportantOperations.class)
public class AnotherImportantConfig implements MyExtension
{
}
----

== Strategies for Implementing Operations

Below you can find some details about how to implement operations.

=== Injecting @UseConfig into an Operation

An operation can access a `@Configuration` class at runtime if any of the operation's arguments are annotated with `@UseConfig`. This injection allows operation access to the configuration when executed, that is, dynamically. See this link:https://github.com/mulesoft/mule/blob/82934f04daabd257c06521751a159b532d7fdbe3/modules/extensions-support/src/test/java/org/mule/module/extension/HeisenbergOperations.java#L69-L69[example].

In the examples above you can see operations which don’t require configuration data, while others do. Those operations implement part of their logic by having an argument annotated with `@UseConfig`.

The reason why you might choose to receive the configuration as a method argument becomes clearer in the *operations lifecycle* section. Note that:

* If the operation receives many arguments, there is no restriction on the position of the argument supporting configuration injection.
* There is no restriction or enforcement regarding the type of the configuration passed as an argument, as long as the type is the same as the configuration
* The argument will _not_ be translated into a `ParameterModel`

=== Operations that Return One Value

An operation can return a single value of any type.

Example:

[source,java,linenums]
----
public String toUpperCase(String value) {
	return value.toUpperCase();
}
----

This operation is adapted into a `MessageProcessor`, which returns a copy of the input message, whose _payload_ has been set to the method's _return value_.

=== Operations that Set Payload and Attributes

When the *payload* and the *attributes* of message must be manipulated and returned by the operation, return an `OperationResult`.

[source,java,linenums]
----
public OperationResult<InputStream, FileAttributes> read(String path) {
	return ...
}
----

`OperationResult` is defined link:https://github.com/mulesoft/mule-extensions-api/blob/1458edadff5d165503b4bf2b11b29eae07ac1cbd/mule-extensions-api/src/main/java/org/mule/runtime/extension/api/runtime/operation/OperationResult.java#L32-L32[here].

This object can return a *payload*, an *attributes object* and a `DataType`. The Mule runtime takes this object and generates a new Mule message, which is then propagated through the pipeline.
//MG: pipeline?

Although the object permits returning a *payload*, an *attributes object* and a `DataType`, it doesn’t require the user to actually provide all three. If none are provided, then the value from the incoming `MuleMessage` will be used.

=== Operations that Return List of Messages

//MG placeholder for new section in spec

=== Void Operations (Not Changing Mule Message)

Void operations do not modify the Mule message in any way:

.Example
[source,java]
----
public void logger(String message) {
}
----

In this case the message that enters the message processor is unchanged after exiting it.

=== Operations Accessing MuleEvent and MuleMessage

In most cases you should avoid interacting with core Mule data such as the message and the event, however in some cases you may find accessing these objects useful.

In regard to operations, a class containing operation methods can have attributes of type `MuleEvent` or `MuleMessage`. The runtime automatically provides them upon invocation of the method.
//MG upon invoking the method they become available

.Example

[source,java,linenums]
----
public Object someOperation(MuleMessage message, String value) {
	…
}
----

=== Operations Setting the DataType

The `MuleMessage` has the concept of `DataType` to provide information about the Mule message payload format, specifically:

* Encoding
* MimeType

Information in the `DataType` is used by Mule transformers to perform automatic transformation. An operation should be able to change the output `DataType` two ways:

* the user should have the chance to cast the data type
* the operation explicitly transforms the data type

=== Operations Forcing a DataType

By annotating a method with `@DataTypeParameters`, the operation can add an `outputEncoding` and `outputMimeType` parameters, allowing the user to ensure the desired output data type when in the application XML code.

[source,java,linenums]
----
@DataTypeParameter
public String read(String path, ContentType contentType) {
	return read(path, contentType.getEncoding());
}
----

That annotation instructs the SDK to automatically add the `outputEncoding` and `outputMimeType` parameters:

[source,xml,linenums]
----
<file:read path="some/path" outputEncoding="UTF-8" outputMimeType="application/json" />
----

=== Operations Determining DataType

An operation on its own can determine the `DataType`.

The solution for this is to simply have an operation which returns a `MuleMessage` with a handcrafted `DataType`. Notice however that if the operation returns a custom DataType but the user forced values on the XSD, the user’s settings will take precedence over the operation’s code.

//MG nested processor implementation not yet final?


=== Paging Operations

Paging lets you avoid out-of-memory issues when processing a large quantity of records. Use SDK's `PagingProvider` interface to process records in chunks.

.Example implementation of paged operation
[source,java,linenums]
----
public PagingProvider<ConnectionImpl, Account> getPagedPersonalInfo(int fetchSize) {


 return new PagingProvider<ConnectionImpl, Account>() {


   @Override
   public List<Account> getPage(ConnectionImpl conn) {
     return conn.getAccounts(fetchSize);
   }


   @Override
   public Optional<Integer> getTotalResults(ConnectionImpl conn) {
     return conn.getTotalPagesForSize(fetchSize);
   }


   @Override
   public void close() throws IOException {
     conn.close()
   }
 };
}
----

[NOTE]
* `getPage()` returns the next "page" of items
* `getPage()` returns an empty list when there are no more items to process
* in some cases, it may not be desirable to retrieve the total quantity of results, in which case force the `getTotalResults()` method to return an `Optional.empty()` value
//MG: is Optional.empty() standard Java expression?

=== Non-Blocking Operations

Mule 4 has a brand new execution engine based on reactive streams. That means there’s top level support for non-blocking operations. By default, all operations are blocking. As you probably noticed, the semantics of all the operation examples we’ve seen above are inherently blocking: the runtime invokes a method and gets a value in response. And that’s fine, since in real life most operations will be blocking (there aren’t much non blocking API’s/protocols out there, APIs such as JMS and DB don’t support non blocking and chances are they never will).

One of the few protocols for which does support this is http. Being able to perform non blocking http request is key for scalability of gateway proxies. Any connector consuming a REST API can also benefit from this.

Let’s see how the SDK allows you to develop non-blocking operations looking at an overly simplified http request operation

public void request(String url, @Connection HttpClient client, @Content String body, CompletionCallback<InputStream, HttpAttributes> callback) {
 client.send(url, body, new HttpResponseCallback() {
   void onResponse(HttpResponse response) {
     callback.success(Result.builder().output(response.getBody())
                          .attributes(toAttributes(response))
                          .build());
   }

   void onError(Exception e) {
     callback.error(e);
   }
 });
}

Let’s dig into the example:

An operation becomes non blocking when it has an argument of type CompletionCallback
Just like configurations and connections, this argument is synthetic and won’t be visible to the user.
Unlike blocking operations, the return type is not specified through the method’s return type:
Non blocking operations always need to be specified through void methods
The return value is passed through the success(Result) method of the CompletionCallback
The declaration of the operation’s output type is done through the callback generics. Those generics are mandatory and cannot be skipped
Non Blocking operations should not throw exceptions. Any errors should be channeled through the error() method in the callback
Notice that in this example, the CompletionCallback is being consumed from between an HttpResponseCallback. This second callback is provided by an httpClient which supports asynchronous responses itself. As stated before, in order to do non blocking, you need to be consuming an API which allows that.

So the result of this code, is a non blocking operation which returns an InputStream as payload and a HttpAttributes object as message attributes.

=== Void Operations (non-blocking)

The use case is an I/O operation which doesn’t return anything, such as writing to a file:

[source,java,linenums]
----
public void write(String path, @Content byte[] bytes, CompletionCallback<Void, NullAttributes> callback) {
 ...
}
----


As you can see here, you can use void and NullAttributes to represent an operation which is void.
