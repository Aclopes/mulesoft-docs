= Connection Management
:toc-macro:
:toclevels: 3


toc::[]

== Overview

In this section, learn to define how your module should use Mule to:

* Create a connection to a service
* Reconnect to the service
* Handle connection retries and
* Support different connection mechanisms
// oauth, http basic, etc?

[NOTE]
====
Essential annotations you use in your code to support connection management are:

* `@ConnectionProviders`
* `@Connection`
====

== What is a ConnectionProvider?

At the heart of the connectivity framework of Mule SDK is the `ConnectionProvider` interface, which is responsible for:

* *creating a connection*,
* *disconnecting*, and
* *describing* the connection for Mule runtime handling purposes.

[NOTE]
Inspect the link:https://github.com/mulesoft/mule-api/blob/2feae79470691d95a64bf79f062d07b5b8478588/src/main/java/org/mule/api/connection/ConnectionProvider.java[ConnectionProvider interface] more detail to see how the interface handles the above aspects of the connection.

Although this is decoupled from a compilation point of view, there’s a strong lifecycle coupling between a configuration instance and a `ConnectionProvider`. A connectable configuration instance is tightly bound to a `ConnectionProvider` instance through the Mule runtime `ConnectionManager`.

The `@ConnectionProviders` annotation is used to declare the `ConnectionProviders` that your module defines, following the same patterns as `@Configurations` and `@Operations`.

== Connection Handling Strategies

By default, a connection is created each time an operation needs one and is destroyed each time the operation finishes. In some cases you need another approach. There are three types of management strategies:

* *POOLING*: User can configure whether the connections should be pooled or handed off directly. The `ConnectionType` provides a default `PoolingProfile`. You can enable this strategy by making the `ConnectionProvider` implement the `PoolingConnectionProvider` interface
When pooling is enabled, XSD support is automatically added to configure a `<pooling-profile />` element. If no such element is defined, a default one is used. Therefore, the `PoolingConnectioProvider` implementation in not required to have a field of type `PoolingProfile`.
* *CACHED*: Per each configuration instance, a connection is established and cached so that one specific config always gets the same connection. The connection is maintained until the configuration itself is stopped. You can enable this strategy by making the `ConnectionProvider` implement the `CachedConnectionProvider` interface.
* *NONE*: This is the default case. The runtime adds no additional infrastructure as in the Pooling/OAuth strategies. The `ConnectionProvider` is responsible for providing the entire connection handling behavior.

== Connection Handling Examples

[NOTE]
The below implementations are not tied to the actual connectors being implemented like this.


=== Custom Pooling Profile

This is an example of a `PoolingConnectionProvider`, for which a custom pooling profile is configured. Consider a JMS connection with an activemq provider.

[source,xml,linenums]
----
<jms:config brokerUrl="..." user="" pass="">
	<jms:activemq-connection >
		<pooling-profile maxActive="10" />
	</jms:activemq-connection-provider>
</jms:config>
----

=== Pooling Disabled

In this example, we see how to use pooling. If the user wants, he can use it with unpooled connections.

[source,xml,linenums]
----
<jms:config brokerUrl="..." user="" pass="">
	<jms:activemq-connection >
		<pooling-profile disabled="true" />
	</jms:activemq-connection-provider>
</jms:config>
----

=== Default Pooling


Or simpler form using defaults:

[source,xml,linenums]
----
<ftp:config user="" pass="" host="" port="" workingdDirectory="" />
----

=== Supporting Pooling and OAuth2


Finally, consider the case of the Salesforce connector which supports both, pooled connections and OAuth2 connections.

[source,xml,linenums]
----
<sfdc:config>
	<sfdc:oauth2-connection accessTokenUrl="" defaultAccessTokenId="" …. />
</sfdc:config>
----

== OAuth


OAuth is huge and fundamentally different from the other cases. It’s listed in this document just to enunciate that the @Connection annotation model fits this case too, but the other specifics will be treated as a separate spec.


== Connection Validation


By contact, the connect(Config) method in the ConnectionProvider must return a valid, fully functional connection. However, when connections are pooled, they might become stale while sitting idle.


To prevent that, the ConnectionProvider has the validate(Connection) method which will be invoked before a connection is returned from the pool. Language is important to understand this functionality:


When an operation requires a connection and the current configuration triggers a behavior for which the connection is created at that moment, the validate method will not be invoked.
When an operation requires a connection which is already available in a pool, then the validate method will be invoked.


If the validation fails, then the connection will be invalidated and a new one will be taken from the pool. That behavior will continue until a valid one is obtained.


=== ConnectionValidationResult

The validate(Connection) method will return an object of type ConnectionValidationResult. That object will look as follows:


https://github.com/mulesoft/mule-api/blob/e166e97a8dcfb9349b743e46608785c4d2e6ce46/src/main/java/org/mule/api/connection/ConnectionValidationResult.java


This pojo not only says if the exception is valid. Also, it  provides a message, code and optionally an exception which gives context about why the connection is actually invalid.


=== Disabling validation


In some cases, the validation of the connection might turn expensive. For example, in the case of FTP, the connection validation is to seen a NOOP command. If the latency to the FTP server is high, it might constitute a problem. For those cases, a disableValidation attribute will be added to the connection providers which support pooling and cache.


On XML:


<ftp:config user="" pass="" host="" port="" workindDirectory="">
	<ftp:connection disableValidation="true" />
</ftp:config>




== Reconnection


The thing with connections is that they get stale or invalid. When they crash, you need to reconnect. Mule already contains the concept of reconnection policy which is configured through the <reconnect /> and <reconnect-forever /> XML elements. This can be leveraged on the connectors in the same way as the profile is:


<ftp:config user="" pass="" host="" port="" workindDirectory="">
	<ftp:connection disableValidation="true">
<reconnect frequency="5000" count="3"/>
	</ftp:connection>
</ftp:config>


The above configuration will attempt reconnection up to three times with a frequency of 5000 milliseconds. If no reconnection policy is supplied, then no reconnection takes place and the operation simply fails without retries.


Users are not forced to provide a reconnection policy. The default value is to not reconnect.


=== Reconnection dynamics


Reconnection will happen each time an operation or message source fails with a ConnectionException, or a ConnectionException can be found on the error’s cause tree. When that happens the runtime will:


Log an error
Invalidate the connection
Depending on the retry policy, it will obtain a new connection and:
For the operation case, retry the operation as many times as the retry policy allows until the operation either finishes or fails with an exception other than ConnectionException.
For the MessageSource case, it will stop and restart it using the newly obtained connection.


=== Reconnection configuration


Operations
For operations the retry policy will be defined at connection level, as is explained in the example of above, and will impact in all operations that are configured with the config that uses the connection with the retry policy. There is no way to override the retry policy for a particular Operation.
Sources
For sources, unlike the operations, the retry policy must be defined at Source level, not leveraging in the one configured at connection level.


<petstore:source config-ref="petstore-config">
  <reconnect/>
</petstore:source>



=== Validation Race Condition


Sometimes, race conditions can appear between a connection’s validation and its actual expiration or crashing. Consider the following example:


It is common for many Rest API’s to provide an authentication token that needs to be sent as a header on each call. Those tokens are often associated with an expiration time. So even with validation enabled, you could have a token with a 1000 seconds expiration time. That means that an operation might require a connection to be taken out of the pool, and as a result get validated. If that happens 999.99 seconds after the token was issued, then the validation will succeed. However, at the moment of sending the next call, the token will have expired and the operation will fail.


A similar situation can happen with stateful connections: the connection is OK at validation time, but the socket is reset just before sending the next packet.


Handling this corner case will be up to each connector. Implement the validate method in such a way that accounts for a reasonable time buffer so that this doesn’t happen.


== Exception Enricher for Connections


The above is a simple and effective approach, however it puts into the extension the responsibility to tell which of the many exceptions that a connection object can throw are actually due to a connection problem and which are just “business” exceptions. For some connection types it’s easy. In some other cases, things like a JDBC driver will always throw a SQLException and you need to perform complicated analysis to determine if the problem was connection related or not.

This means you need a "try-catch" block around every single operation and perform this analysis on the catch block. Not a lot of garbo in that.

See the documentation on link:/[Exception Enricher], you can define an enricher that does all the exception analysis and throw a new Enriched Connection Exception to trigger a reconnection process. Taking in mind that you can use an Enricher in multiple operations


== Next Step

Look closer at some link:/SDK/connector-examples[connector examples].
