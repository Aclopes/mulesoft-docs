= SDK for Mule 4
:keywords: devkit, development, features, architecture


Create link:/[Mule 4] modules using the *Mule SDK*, the standard framework used to build components, connectors, message sources, and more, for use in Mule 4 applications. The SDK framework provides Java annotations to assist the developer in the work of writing the module.

Mule 4 modules are built using the SDK. The Extensions API is the mechanism that Mule 4 uses to manage module functionality and its resources for a running Mule 4 application.

[IMPORTANT]
*Anypoint Connector DevKit*-built connectors work out of the box with Mule 3.5.3 to Mule 3.9.x. You must use *SDK* to build Anypoint Connectors for Mule 4. Like its predecessor, DevKit, SDK is an annotations-based framework allowing you as the developer to organize and build features for the module. For a complete list of SDK annotations, see the link:/annotation-reference[Annotation Reference].

== What is a module in Mule 4 terms?

A *module* is an entity that is designed, compiled and built to run on Mule 4. A module defines a contract between Mule and something else, for example a cloud service or API. This module, like any Mule component can be dropped into a Mule flow. You may enable the module to work as a message source in order to create events and kick off a flow, or inside a flow to process or dispatch data.

== What tools are available to Mule 4 module developers?

The *module developer* must use the Mule 4 SDK framework to code the module in Java, coding and annotating the necessary classes with decorators according to the some straightforward development guidelines. In this way the developer can expose to the end user of the module (the Mule app developer) the desired functionality. Anypoint Studio is the IDE in which many Mule app developers interact with your module.

[TIP]
Find out next what you need to start developing a module.


== What do I need in order to develop a Mule 4 module?

Ensure your development environment is equipped with the following:

* http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java/JDK 8]
* link:https://maven.apache.org/download.cgi[Apache Maven]
* Mule 4


////
Devkit 3.8 Reqs
. See detailed instructions link:/anypoint-connector-devkit/v/3.8/setting-up-your-dev-environment[here] on how to install:  link:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java JDK version 8], link:https://maven.apache.org/download.cgi[Apache Maven], link:https://www.mulesoft.com/lp/dl/studio[Anypoint Studio], and link:/anypoint-connector-devkit/v/3.8/setting-up-your-dev-environment[Anypoint DevKit Plugin] to build and test your connector. You can develop a connector using Windows, Mac, or Linux.
. _New Connector:_ 
* link:/anypoint-connector-devkit/v/3.8/creating-an-anypoint-connector-project[Anypoint Connector Developer Guide] - Set up Anypoint Studio and install the connector plugin. 

+
_Existing Connector:_
* Click *File* > *Import* > *Anypoint Studio* > *Anypoint Connector Project from External Location*, choose a URL or a .zip file, and complete the wizard to locate and import the project.
+
See also link:/anypoint-connector-devkit/v/3.8/creating-a-soap-connector[Creating a SOAP Connector] or link:/anypoint-connector-devkit/v/3.8/creating-a-connector-for-a-restful-api-using-jersey[Creating a REST Connector Using Jersey].
. link:/anypoint-connector-devkit/v/3.8/setting-up-api-access[Determine resource access] - Each resource has a different access method, such as REST, SOAP, FTP, or the Java SDK features.
. link:/anypoint-connector-devkit/v/3.8/authentication[Choose an authentication mechanism] - Mule supports OAuth V1 or V2, and username and password authentication (known as link:/anypoint-connector-devkit/v/3.8/connection-management[connection management]), which can be used for protocols such as API Key, SAML, NTLM, Kerberos, or LDAP.
. link:/anypoint-connector-devkit/v/3.8/connector-attributes-and-operations[Choose the connector's data model] - Models can be static Java objects or dynamic objects. You can use link:/anypoint-studio/v/7/datasense[DataSense] - Determine what information the target resource expects.
. link:/anypoint-connector-devkit/v/3.8/defining-connector-attributes[Add connector @ attribute annotations] - Create code for your connector containing the @ attributes that Mule uses to designate the important parts of your connector.
. link:/anypoint-connector-devkit/v/3.8/developing-devkit-connector-tests[Code tests] - Tests can be unit tests, functional tests, and Studio interoperability tests.
. link:/anypoint-connector-devkit/v/3.8/connector-reference-documentation[Document your connector] - MuleSoft provides a template that helps you fill in the blanks to create documentation to help your staff and others understand the features and use of your connector.
. link:/anypoint-connector-devkit/v/3.8/packaging-your-connector-for-release[Package your connector].
////

== What is a configuration?

The configuration exposes to the end user required or optional module configuration parameters. In the simplest case, the same class annotated with `@Extension` is _implicitly_ considered a configuration.

Any operation could rely on a configuration. If that is the case, annotate the operation with `@UseConfig`. All modules are required to have at least one configuration, but can also define as many other configurations as needed. Separate configurations naturally offer different parameters, operations, sources (mechanism for generating messages into a Mule flow) and connection providers.

== How do I implement connection management in a module?

Implement a `ConnectionProvider` class to create, handle and return a connection. You may require different connection provider classes depending on the types of connections your module supports: simple, pooled, or cached. Connection providers specify the type of configuration(s) they accept. If the provider is available at the `@Extension` class level, then it has to be compatible with _every_ configuration type in the extension and it has to work with _every_ defined operation. If declared at the "configuration" level, then the provider is only required to work with that configuration and with the operations available to it.

See the link:/connection-management[Connection Management] documentation to learn more.

[NOTE]
Although decoupled from a compilation point of view, there’s a strong lifecycle coupling between a configuration instance and a `ConnectionProvider`. A connectable configuration instance is tightly bound to a `ConnectionProvider` instance through Mule runtime’s `ConnectionManager`.


== How do you recommend I organize my module code?

Here are some guidelines for module development to get you started.

* The main class for the module is the entry point for Mule. It should contain generic information such as the name, description, version, etc. It also contains configurable fields or references the list of available fields by *configurations* and references the *operations*, any *sources* and *connection providers* which are globally available all across the module.

. First declare your module/extension with `@Extension`, and reference any configurations there or reference them with `@Configurations`.
+
[NOTE]
`@Extension` marks a discoverable entry point for discovery and validation of the module for use with Mule. Modules are composed of at least one configuration and a set of operations, whose behavior may be dynamic, that is, dependent on the configuration used.
+
. Declare a connection provider and annotate it with `@ConnectionProviders`
. Annotate the parameters used for the configurations, with `@Parameter`, optionally grouping them with `@ParameterGroup`. By default, "expressions" written in Mule expression language (DataWeave) are supported for use in parameters. Otherwise, you must specify they are not supported.
. Create a class for operations and annotate the class with `@Operations`. Each method in the class would be a single operation.

Note there are guidelines that you must follow in addition to these. Learn about them in the Reference documentation alongside the link:/annotation-reference[Annotation Reference].

== What are the guidelines for coding Configurations and Operations?

* Configurations and operations must be defined in different classes
* If the extension provides several configurations, each one must be defined in its own class, although all of them will be required to belong to have a common ancestor class and/or implement the same interface when defined at the same level
* Operations can be defined in a more flexible way. They can all be defined in the same class, be spread across several classes, or even have a one operation per class model.

[TIP]
Read more in the link:/creating-configurations[Configuration Reference] and link:/adding-operations[Operations Reference].


== What other important functionality do I need to consider implementing?

* *Pagination* for operations that may return large sets of results
* *Error Handling* to map Java errors to Mule error types and declare custom error types, and specify where these errors can be thrown
* *DataSense* to assist the Mule application developer during application design. Proper DataSense support helps the developer know what data a module can input/output at any given point in a flow.
* *XML Support* to allow configuration of the module in a Mule app via XML
* *DataSense Query Language (DSQL)*

== How does Mule 4 interact with a module?

*Extensions API* is the set of interfaces and classes that centralizes all validations and instantiating logic for the module. On deployment of a Mule application, the Extensions API handles communication between the SDK-built module and the Mule 4 runtime, effectively decoupling their respective tasks. The Extensions API has no dependency on Mule core.

////
DevKit features
Features DevKit provides:

* Visual design and implementation using Anypoint Studio with an Eclipse-based interface that simplifies and speeds up development.
* Maven support.
* Connector packaging tools.
* Authentication support for multiple types of authentication, including OAuth and username and password authentication.
* DataSense support to acquire remote metadata.
* Extensive testing capability.
* Examples, training, and support to simplify development startup.
* Batch, Query Pagination, and DataSense Query Language support.
////


////
=== Connector Architecture

Connectors operate within Mule applications, which are built up from Mule Flows, and external resources, which are the targeted resources.

image:DevKitOverviewArchitecture.png[DevKitOverviewArchitecture]

A Mule connector has two operational sides. The Mule-facing side communicates with a resource’s target-facing client side to enable content to travel between the Mule applications, and the external target-facing resource.

==== Mule-Facing Functionality

From the Mule-facing side, a connector consists of:

* *Main Java class*. Java code that you annotate with the `@Connector` attribute. See the link:http://mulesoft.github.io/mule-devkit/[Anypoint DevKit API Reference] for information about Anypoint Connector DevKit annotations. See  link:http://en.wikipedia.org/wiki/Java_annotation[Java annotations] for information on how annotations work. 
* *Connector attributes*. Properties of the `@Connector` class that you annotate with the `@Configurable` attribute. 
* *Methods*. Functionality that you annotate with the `@Processor` attribute.

Additional annotations define authentication-related functionality, such as connection management. Annotations allow you to control the layout of the Anypoint Studio dialogues for the connector as well. The data model and exceptions that either raise or propagate are also Mule-facing classes.

DevKit generates a scaffold connector when you create your Anypoint Connector project in Studio. This scaffold connector includes the `@Connector` class, the `@Configurable` attributes, the `@Processor` methods, and authentication logic to build out your connector.

==== Target-Facing Functionality

The target facing or client facing side of a connector depends on the client technology that enables access to the resource. This functionality consists of a class library and one or more classes that `@Connector` classes use to access client functionality. This functionality is called the client class.

The client class in turn generally depends on other classes to actually implement calls to the targeted resource. Depending on your target, some of these classes may be generated or provided for you. For example, if you have a Java client library, or are working with a SOAP or REST services, most of the client code is implemented there. In other cases, you have to write the code yourself.

== Coding a Connector

DevKit lets you build connectors from scratch. Before creating your own connector, check the link:https://www.mulesoft.com/exchange#!/?types=connector&sortBy=name[Anypoint Exchange] for available connectors. The connectors page also lists Community open source connectors that let you contribute to the growing community of public connector development.

==== Connector Data Model

The data model for the connector consists of the objects passed into and out of the exposed operations. While many Web services accept and return XML or JSON data, a proper Mule connector must translate the data format the client uses into Java objects – either POJOs or key-value maps which represent the data objects sent to, and returned from, the target. (Returning raw XML or JSON responses to Mule is one marker for an immature, improperly implemented connector.)

==== REST Versus SOAP

REST simplifies access to HTTP using POST, GET, PUT, and DELETE calls to provide access to creating, getting, putting, and deleting information on a resource.

DevKit currently provides a strategy for link:/anypoint-connector-devkit/v/3.8/creating-a-connector-for-a-restful-api-using-jersey[Creating a Connector for a RESTful API Using Jersey] to build a REST API-supported connector.

SOAP is a traditional means of communicating with a resource and requires a WSDL file, which is an XML file that specifies all aspects of a Java class’s structure, methods, properties, and documentation. SOAP is an industry standard with tools for governance, building, and schema information. DevKit provides a tools that helps building a connector using a WSDL file. 

==== DevKit 3.8 Example Default Connector

The following is an example of the starting `@Connector` and `@Configuration` classes that DevKit 3.8 creates:

[source, java, linenums]
----

package org.mule.modules.demojdk;

import org.mule.api.annotations.Config;

@Connector(name="demo-jdk", friendlyName="DemoJDK")
public class DemoJDKConnector {


        @Config
    ConnectorConfig config;

    /**
     * Custom processor
     *
     * @param friend Name to be used to generate a greeting message.
     * @return A greeting message
     */
    @Processor
    public String greet(String friend) {
        /*
         * MESSAGE PROCESSOR CODE GOES HERE
         */
        return config.getGreeting() + " " + friend + ". " + config.getReply();
    }

    public ConnectorConfig getConfig() {
        return config;
    }

    public void setConfig(ConnectorConfig config) {
        this.config = config;
    }
}
----

The DevKit 3.8 `@Configuration` class is as follows:

[source, java, linenums]
----
package org.mule.modules.demojdk.config;

import org.mule.api.annotations.components.Configuration;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.param.Default;

@Configuration(friendlyName = "Configuration")
public class ConnectorConfig {

    /**
     * Greeting message
     */
    @Configurable
    @Default("Hello")
    private String greeting;

    /**
     * Reply message
     */
    @Configurable
    @Default("How are you?")
    private String reply;

    /**
     * Set greeting message
     *
     * @param greeting the greeting message
     */
    public void setGreeting(String greeting) {
        this.greeting = greeting;
    }

    /**
     * Get greeting message
     */
    public String getGreeting() {
        return this.greeting;
    }

    /**
     * Set reply
     *
     * @param reply the reply
     */
    public void setReply(String reply) {
        this.reply = reply;
    }

    /**
     * Get reply
     */
    public String getReply() {
        return this.reply;
    }
}
----

== Anypoint Connector DevKit Features

DevKit supports:

*Authentication Types*

*  link:/anypoint-connector-devkit/v/3.8/connection-management[Connection Management] (username and password authentication)
* link:/anypoint-connector-devkit/v/3.8/oauth-v1[OAuth V1]
* link:/anypoint-connector-devkit/v/3.8/oauth-v2[OAuth V2]
* Other authentication schemes:  link:/anypoint-connector-devkit/v/3.8/authentication-methods[Authentication Methods]

*API Types*

* link:/anypoint-connector-devkit/v/3.8/creating-a-connector-for-a-soap-service-via-cxf-client[SOAP APIs]
* link:/anypoint-connector-devkit/v/3.8/creating-a-connector-using-a-java-sdk[Java SDKs]

*Anypoint Platform*

* link:/anypoint-connector-devkit/v/3.8/adding-datasense[DataSense]
* link:/anypoint-connector-devkit/v/3.8/adding-datasense-query-language[DataSense Query Language]
* link:/anypoint-connector-devkit/v/3.8/adding-query-pagination-support[Query Pagination]
* link:/anypoint-connector-devkit/v/3.8/building-a-batch-enabled-connector[Batch]
* link:/anypoint-connector-devkit/v/3.8/installing-and-testing-your-connector-in-studio[Anypoint Studio Support]

*Connector Development Lifecycle*

* link:/anypoint-connector-devkit/v/3.8/setting-up-your-dev-environment[Setting Up a Connector Project]
* link:/anypoint-connector-devkit/v/3.8/creating-a-java-sdk-based-connector[Writing Connector Code]
* link:/anypoint-connector-devkit/v/3.8/developing-devkit-connector-tests[Writing Connector Tests]
* link:/anypoint-connector-devkit/v/3.8/connector-reference-documentation[Documenting a Connector Project]
* link:/anypoint-connector-devkit/v/3.8/packaging-your-connector-for-release[Packaging a Connector]

== See Also

* link:/anypoint-connector-devkit/v/3.8/anypoint-connector-development[Connector Development] - Provides steps to follow from setup to packaging a connector.
* link:/mule-user-guide/v/3.7/anypoint-connectors[Anypoint Connectors] - How to use and implement connectors - this section is in the Mule User Guide.
* link:https://www.mulesoft.com/exchange#!/?types=connector&sortBy=name[Connectors] - Connectors available from MuleSoft or third party sources.
* link:/anypoint-studio/v/7/datasense-enabled-connectors[DataSense-Enabled Connectors] - View which MuleSoft connectors support DataSense.
* link:http://mulesoft.github.io/mule-devkit/[Anypoint DevKit API Reference] - Describes DevKit elements that start with an at sign(@), which you can use in your connector to identify classes and functions for Anypoint functionality.
* Example connector models you can use to build your own:
** link:/anypoint-connector-devkit/v/3.8/devkit-tutorial[DevKit Tutorial]
** link:/anypoint-connector-devkit/v/3.8/creating-a-connector-using-a-java-sdk[Creating a Connector Using a Java SDK]
** link:/anypoint-connector-devkit/v/3.8/creating-a-connector-for-a-soap-service-via-cxf-client[Creating a Connector for a SOAP Service Via CXF Client]
** link:/anypoint-connector-devkit/v/3.8/creating-a-connector-for-a-restful-api-using-jersey[Creating a Connector for a RESTful API Using Jersey]
////
