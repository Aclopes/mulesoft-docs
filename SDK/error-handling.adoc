= About Error Handling Support
:toc-macro:
:toclevels: 3


toc::[]


In this section you learn how to implement the `ErrorTypeDefinition` class to define errors, as well as set up the `ErrorTypeProvider` class so that your operation can actually throw the errors you want it to be able to throw. It is possible to throw errors explicitly. Additionally, you can enrich exceptions by using `@OnException`, sending any exception thrown to an enricher class, which you implement to provide specialized handling.

== Background on Mule Error Handling

Note that Mule 4 enables the integration developer to leverage errors defined in Mule. Therefore, you as the Mule module developer should allow the users of your module to handle any possible Java exceptions that can be thrown, by mapping these to Mule errors, and at times going further to enrich those errors. You can define various error types for your module to throw.
//MG: is this correct terminology? map Exceptions to Errors?
`ErrorType` is the identifier that you use to identify the Mule error, or other specialized error, that your module can throw, which helps the user identify the origin of any given issue.

[NOTE]
When a MuleEvent fails it contains an Error object, which contains an `ErrorType` and information about the error. For example, one possible Mule `ErrorType` is `MULE:CONNECTIVITY`.

SDK enables the module developer to declare the *error types* that can be thrown by the module and where they can be thrown, for example at the *operation or configuration levels*. Implement the `ErrorTypeProvider` to specify which error types can be thrown.
//what are the levels at which the errors can be thrown at runtime
* Map the existing Java exceptions to Mule errors in the ErrorTypesDefinition
* Declare which components can throw errors, including the type of the errors


[source,java,linenums]
----
public enum HeisenbergErrors implements ErrorTypeDefinition<HeisenbergErrors> {
 ORPHAN_ERROR,
 CONNECTIVITY {
   @Override
   public Optional<ErrorTypeDefinition<?>> getParent() {
     return Optional.of(MuleErrors.CONNECTIVITY);
   }
 },


 OAUTH2 {
   @Override
   public Optional<ErrorTypeDefinition<?>> getParent() {
     return Optional.of(HeisenbergErrors.CONNECTIVITY);
   }
 }
}
----

With a little sugar:

[source,java,linenums]
----
public enum HeisenbergErrors implements ErrorTypeDefinition<HeisenbergErrors> {


 ORPHAN_ERROR,
 CONNECTIVITY(MuleErrors.CONNECTIVITY),
 OAUTH2(HeisenbergErrors.CONNECTIVITY),
 HEALTH(HeisenbergErrors.CONNECTIVITY);


 private ErrorTypeDefinition<?> parentErrortype;


 HeisenbergErrors(ErrorTypeDefinition parentErrorType){
   this.parentErrortype = parentErrorType;
 }


 HeisenbergErrors(){
 }


 @Override
 public Optional<ErrorTypeDefinition<? extends Enum<?>>> getParent() {
   return ofNullable(parentErrortype);
 }
}
----


== Error Type Declaration

Each error should have an error types definition implementing the interface `ErrorTypeDefinition`. This must be an `enum` class defining the error types.

To declare error types that a module handles, the module developer should declare at the `@Module` level the error types definition class with an `@ErrorTypes` annotation which requires as value a Enum Class implementing ErrorTypeDefinition.
//reuires as value?

Error types are declared at the `@Extension` level referencing the class with the error types definition.

Below is the class you implement to create your error types definition. You annotate your class with `@ErrorTypes`.

[source,java,linenums]
----
public interface ErrorTypeDefinition<E extends Enum<E>> {


 /**
  * @return The type of the current error type definition
  */
 default String getType() {
   return ((E) this).name();
 }


 /**
  * @return The {@link Optional} parent of the current error type definition
  */
 default Optional<ErrorTypeDefinition<? extends Enum<?>>> getParent() {
   return empty();
 }
}
----

=== Error Type Provider

Implement the `ErrorTypeProvider` to specify the error types that can be thrown by operations. In the module code, whenever you want to specify the errors that an operation or other can throw, you use the `@Throws` annotation, referencing the `ErrorTypeProvider` class.

[source,java,linenums]
----
public interface ErrorTypeProvider {


 /**
  * @return a {@link Set} of {@link ErrorTypeDefinition}
  */
 Set<ErrorTypeDefinition> getErrorTypes();
}
----

`@Throws` is used to annotate your `ErrorTypeProvider` class returning a `Set` of error type definitions, all of which must be in the `ErrorTypeDefinition` class. `@Throws` can be applied at the `@Module`, `@Operations`, and at the methods of the `@Operations`. Note you cannot throw an error at the configuration cannot level. A connection exception is automatically exposed as `<module:CONNECTIVITY>`, extending the Mule connectivity error type.

The module developer can inherit an `ErrorType` defined by Mule. For example, an module can throw a connectivity error that extends from a Mule defined connectivity error.

As a consequence, all the declared errors inside a module would be part of the same namespace, so the module developer should, upon specifying the correct namespace, worry only about the error type.
//assuming module=module?
//can the Mule error type be customized via the module. Where is a module's namespace identified in the code?

[NOTE]
Example: If the Slack module declares the `NOT_FOUND` error for a certain operation, this will be registered as `SLACK:NOT_FOUND` error.
//all-caps?

The purpose of the restriction on error declaration is to impose a standardized way to expose module errors and also ensure a consistent experience for the developer handling errors in a Mule application. For a module developer, this provides a streamlined development experience. For the Mule app developer, a consistent experience across all modules.

=== @Throws

Use this annotation to throw an exception. Deepest `@Throws` declarations override any parent `@Throws` declaration.

== Other Options for Throwing Errors

You can throw a `ModuleException` anywhere in your module if you know exactly the `ErrorType` you want to throw (note: it has to have been defined already in your module's error definitions).

You can implement an `ExceptionEnricher` is going to be used, but letting the user throw a new kind of exception, the ModuleException.
This exception is built from a cause exception and an ErrorIdentifier; with this new exception, the module developer can explicitly declare the error type to be thrown.

[IMPORTANT]
Use a `ModuleException` or the error will be reported to the user as `<MODULE:UNKNOWN>`.

The Mule application developer cannot catch an `UNKNOWN` error.

=== Enriching Exceptions

By using the `@OnException` annotation you can point to an `ExceptionEnricher` implementation so when an exception occurs in an operation the Enricher class declared will be called immediately, passing the exception thrown by the operation to the `enrichException` method.

[source,java,linenums]
----
@Extension
@Configurations({PooledConnectionConfig.class, OAuthConfig.class, RestConfig.class})
@Operations(Operations.class);
@OnException(PetExceptionEnricher.class)
public class PetStoreConnector {
…
}
----

You can also define an enricher in an operation method or source class. Handlers defined at operation or source level override whatever setting on the extension level.

[source,java,linenums]
----
@Operation
@OnException(handler = OperationSpecific.class)
public void myOperation() {
}
----

The semantics of the `ExceptionEnricher` is such that it can either be used to decorate a given exception but it can also be used to handle the exception directly and return a value back into the pipeline.

For example, consider the following:

[source,java,linenums]
----
public class PetExceptionEnricher implements ExceptionEnricher {

	public Exception handleException(Exception e) {
		if (e instanceof SocketException) {
return new ConnectionException(e);
} else {
		logger.debug(“Oh no!”, e);
		}
		return e;
}
----

What the `ExceptionEnricher` interface allows is to provide generic logic to handle exceptions, either via logging, sending notifications, etc.

Optionally, you can throw a new exception which replaces the original one. In this case, we wrap the SocketException into a ConnectionException, so that the runtime gets to know that reconnection is needed. Notice that this implies that the handler should not fail by any other reason.

This is the Exception Enricher interface that you implement to receive the exception thrown by the operation and returns another exception enriched or just the same one after doing some processing.

[source,java,linenums]
----
public interface ExceptionEnricher {


public Exception enrichException(Exception e);
}
----
