= About the For Each Scope


The Foreach scope splits a collection into elements and processes them one by one through the components that you place in the scope. It then regroups them into a single message containing a collection. It's similar to a for-each/for-loop code block in most programming languages.

It Can process any type of collection, including maps, lists, arrays.


== Differences With a Splitter

The For Each scope performs a similar task to using a Splitter and then and Aggregator. The main difference is that the For Each scope outputs a collection just like the one it receives, the Aggregator outputs a message where the payload is a list of mule messages (each with its own payload and attributes).


== Custom Parsing

If the input is a simple collection, the For Each scope can parse it

You can optionally use an expression to split data in a custom way


"#[payload.topic]"

Note that if the input contains information outside the collection you want to split, like a header of footer, this information is lost. (?)




Optional) Default value = counter - Enter a name in this field to label the variable that Foreach uses to record the number of the elements it has processed.

Batch Size
Enter an integer to indicate the number of elements in each batch that Foreach processes. Potentially, these batches promote quicker processing. If greater than one, each batch is treated as a separate Mule message. For example, if a collection has 200 elements and you set the batch size to 50, Foreach iteratively processes 4 batches of 50 elements, each as a separate Mule message.

Optional) Default value = rootMessage - Enter a name in this field to label the variable that Foreach uses to reference the complete, unsplit message collection. If your collection already uses the label rootMessage for another variable, this field is blank and you need to enter a different label for the Root Message Variable Name.


== Error Handling

If one of the elements in a collection throws an exception, Foreach stops processing that collection and invokes the error handler.

== Persisting Data

In case the message inside the foreach scope is persisted, not only the item in the collection is serialized but also all the variables associated with the current message. The rootMessage variable, associated with the message, contains a reference of the complete, unsplit message collection that could potentially be holding thousands of items. Therefore, serialization/deserialization of the rootMessage variable could impact memory consumption considerably when this collection is large enough.

To avoid this issue you must first remove the rootMessage variable from the message before persisting it. For this you can use the <remove-variable> element like so:


== See Also
