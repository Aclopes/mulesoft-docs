= Socket Extension
:keywords: tcp, udp, transport, sockets, connector
:toc:
:toc-title: Page Contents
:toc-levels: 3


toc::[]


[[what-is]]
== What is the Socket Extension?

UDP and TCP protocols and are bundled and configured in one functional entity called the *Socket extension*. The sockets extension provides connectors that can send messages using UDP or TCP sockets. A listener or a requester can be configured for each protocol.

== How to Configure

There are two configurations for the Sockets extension, one for setting up a listener source (receiver), and another one for the requester used in the `send` operation (requester). The default encoding can be overridden by specifying the `defaultEncoding` in the configuration.

* link:/specify-protocol[Configure How TCP Data Stream Converted to Messages]


////
For reference doc:

== Connection Attributes

=== Attributes Common to All

|===
|+sendBufferSize+|+Size of the buffer (in bytes) used when sending data, set on the socket itself.+|+Default determined by the socket+
|+receiveBufferSize+|+Size of the buffer (in bytes) used when receiving data, set on the socket itself.+|+Default determined by the socket for TCP. For UDP it is ++16384+
|+reuseAddress+|+If set, SO_REUSEADDRESS is set on server sockets before binding. This helps reduce "address already in use" errors when a socket is re-used.+|+Defaults to true+
|+clientTimeout+|+This sets the SO_TIMEOUT value on sockets. Indicates the amount of time (in milliseconds) that the socket will wait in a blocking operation before failing.+|+Default determined by socket (wait indefinitely)+
|===


=== TCP Attributes (both listener and requester)


|===
|+sendTcpNoDelay+|+If set, transmitted data is not collected together for greater efficiency but sent immediately. Defaults to true.+|+Defaults to true+
|+linger+|+Sets the SO_LINGER value. This is related to how long (in milliseconds) the socket will take to close so that any remaining data is transmitted correctly.+|+Default determined by socket +
|+keepAlive+|+Enables SO_KEEPALIVE behavior on open sockets. This automatically checks socket connections that are open but unused for long periods and closes them if the connection becomes unavailable.+|+Default determined by socket +
|+failOnUnresolvedHost+|+If set, it will fail during socket creation if the host set on the endpoint cannot be resolved. However, it can be set to false to allow unresolved hosts (this is useful in some circumstances like connecting through a proxy).+|+Defaults to true+
|#heading=h.q0j44nawk5n9[+protocol]+|+Application level protocols with the corresponding logic for sending and receiving data.+|#heading=h.68oj4qxbeqtl[+SafeProtocol]+
|===


=== UDP Attributes (both listener and requester)

|===
|+broadcast+|+Enable/disable SO_BROADCAST in the DatagramSocket+|+Defaults to false+
|===
////

== SSL

To use SSL over a TCP connection, the only thing that needs to be done is configure a TLS context to the TCP Connection Provider (both listener and requester).

[source,xml,linenums]
----
<tls:context name="tlsContext">
   <tls:trust-store path="tls/ssltest-cacerts.jks" password="changeit"/>
   <tls:key-store path="tls/ssltest-keystore.jks" keyPassword="changeit" password="changeit"/>
</tls:context>


   <sockets:tcp-listener-connection host="localhost"
                                    port="${port}"
                                    tlsContext="tlsContext"/>


<sockets:tcp-requester-connection host="localhost" port="${port}"
                                 failOnUnresolvedHost="true"
                                 sendTcpNoDelay="true"
                                 tlsContext="tlsContext"/>
----


Take into account that if the TLS Context is going to be used in a tcp-listener-connection (server side),  the keystore must be configured.
