= Adding Operations to an Extension
:toc: macro
:toclevels: 2
:toc-title:



toc::[]



After creating a configuration, add functionality to your extension by declaring its operations. In the previous version of SDK, called *DevKit*, operations were referred to in development terms as "message processors". Similarly, the operations discussed here can operate on Mule message data.

== Declaring Operations

Operations are declared in a similar way as configurations, with the additional restriction that a class that has been annotated to serve as an configuration cannot also contain configurations. You can use the `@Operations` annotation to point to the classes which hold the operations.

* Every public method of the `@Operations` class is assumed to be a valid operation, therefore there is no need to use any annotation.
* Any public method you don’t want exposed as an operation should be annotated with `@Ignore`
* Every method argument is translated as a `ParameterModel`
//MG need to mention ParameterModel? What does this model allow Extensions API to do?
* Arguments of each operation (`@Operations` class method) can be annotated with `@Optional` and with `@Expression`

The two operation classes link:https://github.com/mulesoft/mule/blob/82934f04daabd257c06521751a159b532d7fdbe3/modules/extensions-support/src/test/java/org/mule/module/extension/HeisenbergOperations.java#L44-L44[Heisenberg operations class] and link:https://github.com/mulesoft/mule/blob/b53d11bf70a167124c78c800924e6e3b8c3abb45/modules/extensions-support/src/test/java/org/mule/module/extension/MoneyLaunderingOperation.java#L13-L13[MoneyLaundering operation class] contain many operation examples. See how we refer to them from the `@Extension` annotated class.

[source,java,linenums]
----
@Extension(name = "heisenberg", description = "heisenberg extension")
@Operations({HeisenbergOperations.class, MoneyLaunderingOperation.class})
public class HeisenbergExtension
{
}
----



== Defining Operations at the Configuration Level

Operations can also be defined at the configuration level by simply placing the `@Operations` annotation on a configuration class.


[source,java,linenums]
----
@Extension(name = "heisenberg", description = "heisenberg extension")
@Configurations({BlueHeisenbergConfig.class, PseudoEfedrinHeisenbergConfig.class})
public interface HeisenbergExtension
{
}


@Configuration(name = "blue")
@Operations(BlueOperations.class)
public class BlueHeisenberg implements HeisenbergExtension
{
}


@Configuration(name = "pseudo")
@Operations(PseudoOperations.class)
public class PseudoEfedrinHeisenberg implements HeisenbergExtension
{
}
----

== Implementing Operations

Below you can find some details about how to implement operations.

=== Injecting @UseConfig into Operation Method

An operation can access a `@Configuration` class at runtime if one or many arguments of the operation are annotated with the `@UseConfig` annotation. This injection mechanism allows access to the configuration dynamically as the operation is executed. See this link:https://github.com/mulesoft/mule/blob/82934f04daabd257c06521751a159b532d7fdbe3/modules/extensions-support/src/test/java/org/mule/module/extension/HeisenbergOperations.java#L69-L69[example]

In the examples above you can see operations which don’t require configuration data, while others do. Those operations implement part of their logic by having an argument annotated with `@UseConfig`.

The reason why you might choose to receive the configuration as a method argument becomes clearer in the *operations lifecycle* section. Note that:
//MG why receive a configuration as an argument? receive user-defined fields?


* If the operation receives many arguments, there is no restriction on the position of the argument supporting configuration injection.
* There is no restriction or enforcement regarding the type of the configuration passed as an argument, as long as the type is the same as the configuration
* The argument will _not_ be translated into a `ParameterModel`

=== Returning Values and Message Attributes

An operation can return a single value of any type.

Example:

[source,java,linenums]
----
public String toUpperCase(String value) {
	return value.toUpperCase();
}
----

This operation is adapted into a `MessageProcessor`, which returns a copy of the input message, whose _payload_ has been set to the method's _return value_.

=== Setting Payload and Attributes through Operation

When the *payload* and the *attributes* of message must be manipulated and returned by the operation, return an `OperationResult`.

[source,java,linenums]
----
public OperationResult<InputStream, FileAttributes> read(String path) {
	return ...
}
----

`OperationResult` is defined link:https://github.com/mulesoft/mule-extensions-api/blob/1458edadff5d165503b4bf2b11b29eae07ac1cbd/mule-extensions-api/src/main/java/org/mule/runtime/extension/api/runtime/operation/OperationResult.java#L32-L32[here].

This object can return a *payload*, an *attributes object* and a `DataType`. The Mule runtime takes this object and generates a new Mule message, which is then propagated through the pipeline.
//MG: pipeline?

Although the object permits returning a *payload*, an *attributes object* and a `DataType`, it doesn’t require the user to actually provide all three. If none are provided, then the value from the incoming `MuleMessage` will be used.

=== Void Operations

Void operations do not modify the Mule message in any way:

.Example
[source,java]
----
public void logger(String message) {
}
----

In this case the message that enters the message processor is unchanged after exiting it.

=== Accessing MuleEvent and MuleMessage

In most cases you should avoid interacting with core Mule data such as the message and the event, however in some cases you may find accessing these objects useful.

In regard to operations, a class containing operation methods can have attributes of type `MuleEvent` or `MuleMessage`. The runtime automatically provides them upon invocation of the method.
//MG upon invoking the method they become available

.Example

[source,java,linenums]
----
public Object someOperation(MuleMessage message, String value) {
	…
}
----

== Operations Lifecycle

Classes which define operations can have the following characteristics:

* Can hold state, but must be thread safe
* Part of that state can be made of dependencies injected through the `@Inject` annotation
* Can implement Mule’s lifecycle annotations
//MG how does developer ensure ops are thread safe? what are the Mule lifecycle annotations?


An instance of the `@Operations` annotated class is created each time the operation is defined in a pipeline. For example:

[source,xml,linenums]
----
<mule>
	<heisenberg:config name="heisenberg" myName="#[name]" />


<flow name="flow1">
	<set-payload value="blah" />
	<heisenberg:build-meth purity="100" />
</flow>


<flow name="flow2">
<heisenberg:build-meth purity="100"/>
<heisenberg:build-meth purity="90" />
</flow>
</mule>
----

For this sample configuration, three instances of the `BlueMethFactory` class are created. One for `flow1` and two for `flow2`.

Notice however that the `heisenberg` configuration is dynamic, so potentially each execution of the method annotated with `@Operation` can receive a different instance of the configuration.
//MG in what cases would the Configuration injected by @UseConfig be different?
At the same time, it should be possible for the `BlueMethFactory` class to keep state if, for example, it wanted to keep track of how many invocations it received. For that reason, it is not possible to keep the configuration as part of the instance state and must be passed by argument each time.

== Setting the DataType

The MuleMessage uses the definition of a data type `DataType` to provide information about the message payload's format, specifically:

* Encoding
* MimeType

Information in the DataType is used by Mule transformers to perform auto-transformation. An operation should be able to change the output `DataType`

* the user should have the chance to cast the data type
* the operation explicitly transforms the data type

=== User-Forced DataType

By annotating a method with `@DataTypeParameters`, the operation can add an `outputEncoding` and `outputMimeType` parameters, allowing the user to ensure the desired output data type.

[source,java,linenums]
----
@DataTypeParameter
public String read(String path, ContentType contentType) {
	return read(path, contentType.getEncoding());
}
----

That annotation instructs the SDK to automatically add the `outputEncoding` and `outputMimeType` parameters:

[source,xml,linenums]
----
<file:read path="some/path" outputEncoding="UTF-8" outputMimeType="application/json" />
----

=== Operation Calculated DataType
//how does the operation figure out the data type, from what part of the message?
//why is this configured at the operation level and what is the annotation or example of doing this?

Another case is an operation including code to determine the `DataType`.

The solution for this is to simply have an operation which returns a MuleMessage with a handcrafted DataType. Notice however that if the operation returns a custom DataType but the user forced values on the XSD, the user’s settings will take precedence over the operation’s code.

== Operation Sub-processors

Some operations require sub-processes. The annotated method should take one or more arguments of type `NestedProcessor` or `List<NestedProcessor>`. The platform can mask the child chain, but it's the responsibility of the extension implementation to invoke the child process.
//MG how are these annotated? unclear what was meant in spec, esp "besides" - > "The platform provides support for masking the child chain besides the NestedProcessor, but it’s up to the implementation to actually invoke it."


=== Single Nested Processor for an Operation

Receives a single nested processor:

[source,java,linenums]
----
public String killOne(NestedProcessor killOperation, String reason) throws Exception
{
   StringBuilder builder = new StringBuilder("Killed the following because " + reason + ":\n");
   builder.append(killOperation.process()).append("\n");


   return builder.toString();
}
----

=== Multiple Nested Processors for an Operation

Receives many nested processors:

[source,java,linenums]
----
public String killMany(List<NestedProcessor> killOperations, String reason) throws Exception
{
   StringBuilder builder = new StringBuilder("Killed the following because " + reason + ":\n");
   for (NestedProcessor processor : killOperations)
   {
       builder.append(processor.process()).append("\n");
   }


   return builder.toString();
}
----

=== XML Representation of Nested Operations

In XML, the generated schema for the operation creates a nested structure for the sub-processors.

[NOTE]
These sub-processors appear _inside_ a child element whose name corresponds to the name of the `NestedProcessor` attribute. This is to support situations in which you want to declare different sets of nested processors.

[source,xml,linenums]
----
<flow name="killMany">
   <heisenberg:kill-many config-ref="heisenberg" reason="I'm the one who knocks">
       <heisenberg:kill-operations>
           <heisenberg:kill-with-custom-message config-ref="heisenberg" victim="Gustavo Fring" goodbyeMessage="bye bye"/>
           <heisenberg:kill-with-custom-message config-ref="heisenberg" victim="Frank" goodbyeMessage="bye bye"/>
           <heisenberg:kill-with-custom-message config-ref="heisenberg" victim="Nazi dudes" goodbyeMessage="bye bye"/>
       </heisenberg:kill-operations>
   </heisenberg:kill-many>
</flow>

<flow name="killOne">
   <heisenberg:kill-one config-ref="heisenberg" reason="I'm the one who knocks">
       <heisenberg:kill-operation>
           <heisenberg:kill-with-custom-message config-ref="heisenberg" victim="Gustavo Fring" goodbyeMessage="bye bye"/>
       </heisenberg:kill-operation>
   </heisenberg:kill-one>
</flow>
----

== Supporting a Callback

An operation at a position *N* that returns a callback `InterceptingCallback` can wrap all processors in a flow from *N+M*, that is, it processes the previous operation in the chain.
//MG: processes M and then N processors?

=== Considerations for Operation with Callback


* All the considerations in the callback’s javadocs
* The generic is not optional. It MUST be provided
If an operation operates on items other than the payload (attributes, mediaType, etc), then it must return `InterceptingCallback<OperationResult<Payload, Attributes>>`
* The callback can prevent the intercepted chain from being executed through the `shouldProcessNext()` method
* The callback can intercept errors and the resulting `MuleMessage` from the intercepted chain, but it cannot change their values.

Example:

[source,java,linenums]
----
public InterceptingCallback<InputStream> interceptingRead(String path) {
	return new InterceptingCallback<InputStream>() {
		public InputStream getResult() {
			Return read(path);
		}


		public boolean shouldProcessNext() {
			return true;
		}


		public void onSuccess(MuleMessage message) {
			….
		}


		public void onException(Exception e) {
			….
		}


		public void onComplete() {
			cleanUp();
		}
};
}
----

== Operations that Support Paging

Paging lets you avoid out-of-memory issues when processing a large quantity of records. Use SDK's `PagingProvider` interface to process records in chunks.

.Example implementation of paged operation
[source,java,linenums]
----
public PagingProvider<ConnectionImpl, Account> getPagedPersonalInfo(int fetchSize) {


 return new PagingProvider<ConnectionImpl, Account>() {


   @Override
   public List<Account> getPage(ConnectionImpl conn) {
     return conn.getAccounts(fetchSize);
   }


   @Override
   public Optional<Integer> getTotalResults(ConnectionImpl conn) {
     return conn.getTotalPagesForSize(fetchSize);
   }


   @Override
   public void close() throws IOException {
     conn.close()
   }
 };
}
----

[NOTE]
* `getPage()` returns the next "page" of items
* `getPage()` returns an empty list when there are no more items to process
* in some cases, it may not be desirable to retrieve the total quantity of results, in which case force the `getTotalResults()` method to return an `Optional.empty()` value
//MG: is Optional.empty() standard Java expression?

== Introspection of Extension Parameters

We recommend you annotate the parameters of your extension configurations and operations as per the guidance on setting configuration attributes with `@Parameter`, whenever possible.

[IMPORTANT]
====
In cases where your extension must access a POJO that is defined in another .jar stored elsewhere, is shared with other projects or which cannot depend on extension annotates, the POJO is introspected using the JDK's "Introspector" class getters and setters to obtain its properties. Those properties are then turned into parameters. The downsides to this are:

* the parameters are assumed to be optional. There is no support for UI placement via `@Placement`, nor expression support via `@Expression`--defaults are always assumed
//MG: please explain above sentence--esp. "always assuming defaults" - see spec plz
* Value injection occurs through the setter instead of the field itself, as there is no mechanism to verify the setter and the corresponding field have matching names or even exist.
//MG the setter of the JDK operates on the parameter, not the Extensions API?
====

== Parameter Groups

Groups of parameters which have a logical dependency on one another can be grouped; for example, connection parameters like "host", "port", "username" and "password" could be grouped in a single class using `@ParameterGroup`.

[source,java,linenums]
----
@Parameter
private String id;


@ParameterGroup(name = "Connection")
private ConnectionParameters connectionParameters;


final class ConnectionParameters
{


   @Parameter
   private String host;


	 @Parameter
	 private String port;
…
}
----

When it comes to writing the code itself for the extension, you can handle related items inside their own class.
//MG: was this untrue before, could you not write params inside their own class?
From the model point of view, the `ConnectionParameters` class written above would be flattened and added to the component that declares it. The corresponding `ConfigurationModel` would list three parameters: `id`, `host` and `port`, without any reference to the `ConnectionParameters` object.

The same goes for operations:

[source,java,linenums]
----
public void sendMessage(@Content payload, @ParameterGroup(name = "Connection) connectionParameters) {
}
----

[NOTE]
You may not use the `@ParameterGroup` annotation inside a complex object which is being used as a parameter group.
//MG: does this mean: you cannot use nested parameter groups?

=== Making Parameters Exclusive

When imposing restrictions on which parameters cannot be set at the same time as others, use `@ExclusiveOptionals` on the parameter group class. Notice how the `@Optional` is used to indicate the specific parameter to exclude.
//MG: in spec the example does not have the @ParameterGroup annotation, is this correct?
//MG: in addition to making the params optional, they also cannot be set by extension user at same time?

[source,java,linenums]
----
@ExclusiveOptionals(isOneRequired = true)
public class MyParameterGroup {


	@Parameter
	private Pojo notAffectedByExclusiveness;


	@Parameter
	@Optional
	private String name;


	@Parameter
	@Optional
	private Integer ID;
}
----

== Defining Infrastructure Parameters

At the "configurable" and "connection provider" levels of an extension are several types that can be leveraged using the Mule core infrastructure:

* `PoolingProfile`
* `RetryPolicyTemplate`
* `TlsContextFactory`

Declare a parameter as one of these types for any configuration or connection provider that needs one.

[source,java,linenums]
----
public class MyExtension {


	@Parameter
	private PoolingProfile poolingProfile;


	@Parameter
private RetryPolicyTemplate retryPolicy;


@Parameter
private TlsContextFactory tlsContext;
}
----

The resulting XML block would look like:

[source,xml,linenums]
----
<my-extension:config>
	<pooling-profile />
	<reconnect />
	<tls:context />
</my-extension:config>
----

[NOTE]
- The elements are not generated using the name of the annotated field.
- You cannot use more than one parameter of the same type on the same element (a configuration may only have _one_ threading profile)
//MG: what do we mean by element here? in same "configuration element"/configuration defined class?

== TLS Context

`TlsContextFactory` supports the XML element being a global element, and it is also possible to configure it as a reference parameter. The name of the attribute is always generated as `tlsContext`. You can see in the example that the `petstore` configuration references the `tlsContext` by name.

[source,java,linenums]
----
<tls:context name="globalTlsContext">
   <tls:trust-store path="ssltest-cacerts.jks" password="changeit"/>
   <tls:key-store path="ssltest-keystore.jks" keyPassword="changeit" password="changeit"/>
</tls:context>


<petstore:config name="globalTls" tlsContext="globalTlsContext" />
----

`TlsContextFactory` implements the `Initialisable` interface. The injected instance will not be automatically initialized, therefore the extension must apply a lifecycle.
//MG: please clarify what "inject instance" refers to in the spec, as well as what "apply lifecycle" means.

== How to Configure XML Support for Extension

XML support for Mule is made possible through the Spring framework. This means a Mule component/extension must have an XSD schema, `NamespaceHandler` and a set of `BeanDefinitionParsers` and or `FactoryBeans`.

You can customize the `schemaLocation`, `schemaVersion`, and namespace prefix, but SDK will calculate defaults for all of them. For the schema version, the Maven artifact version is used.

== XML DSL

Use the `@Xml` annotation to set namespace details for your extension.

[source,java,linenums]
----
@Extension(name = "heisenberg", description = "heisenberg extension")
@Xml(namespaceLocation = "http://www.mulesoft.org/schema/mule/extension/heisenberg", namespace = "heisenberg")
public class HeisenbergExtension
----

This example is exhaustive and thus shows how users can customize `schemaLocation`, `schemaVersion`, namespace prefix, etc. However, all of those attributes are optional and the SDK will calculate defaults for all of them. In the case of the schema version, it will use the maven artifact version.

=== Declaring the XML Element Alias

Declare the XML element alias using the `@Alias` annotation:

[source,java,linenums]
----
@Alias("ListenPayments")
public class HeisenbergSource extends Source<Void, Serializable>
{
    //…

    @Parameter
    @Alias("poolSize")
    private int corePoolSize;

    //…
}
----

The XML name of the annotated element will be obtained from the declared alias in quotes above, instead of using the class or Java parameter name.

In this case, the resulting XML is:

[source,java,linenums]
----
<flow name="flow1">
<heisenberg:listen-payments poolSize="10" />
</flow>
----

=== Customizing XML Schema Generation

SDK prefers consistent generation for extensions. However, you can in fact customize how the XML is configured, to support parameters of complex types (POJO, lists, maps, etc). SDK provides the `@XmlHints` annotation allowing two booleans whose values you can toggle.
//MG: i don't understand the name of the annotation, what is the connection between Hints and the booleans allowing the types to be defined or referenced inline

* `allowInlineDefinition` - SDK determines through the types if it is possible to define them explicitly through XML (normally through child elements)
//MG: what does it mean to define a type through XML, how is this introspected?
//MG: is `allowTopLevelDefinition` supported?
* `allowReferences` - This customization targets the complex type parameters. Regardless of the complex parameters having a child element or not, there will always be an attribute allowing the user to provide a reference to a MEL expression or a static reference to the Mule registry.
//MG: so MEL and DW are supported at the operation level. There may be cases when a static value in an attribute that allows references to be interpreted as the actual value, and a not a reference to the registry.

A typical example of this is an outbound operation (socket:send, file:write, etc), in which the input parameter is of type Object (because many input types are supported):
+
`<file:write data="Hello" />`
+
This should not match the attribute data to a registry entry of key "Hello", but should map to the actual “Hello” String, which, can be achieved by the following code:
+
`Public void write(@XmlHints(allowReferences=false) Object data) {
}`

=== Schema Generation

//
