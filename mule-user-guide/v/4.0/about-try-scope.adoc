<<<<<<< Updated upstream

=======
>>>>>>> Stashed changes
= About Try Scope

The Try scope allows you to handle errors that may occur when attempting to execute its child components. It distinguishes different error types, and can apply different behaviors accordingly. You can also configure what happens to execution upon an error.

<<<<<<< Updated upstream
== Error Handling

You can set different paths to be executed depending on the error type. These paths can also use different strategies, explained below.

* On Error Continue
+
If an error occurs within the try scope, any other components in the scope are skipped, and execution continues inmedately after the scope ends.



 the entire flow breaks execution. If the try scope is nested within another try scope, it continues outside the other scope
If a transaction is being handled, it's committed.
+
image:about-try-scope-46faf.png[]



* On Error Propagate
+
If an error occurs within the try scope, execution continues directly outside the next element in the flow
If a transaction is being handled, it's rolled back.
+
image:about-try-scope-33c5d.png[]

* On Error Retry
+
If an error occurs within the try scope, the entire scope is attempted again.
+ diagram

=== Select conditions

A single try scope can have multiple error handlers, depending on the type of the error.



Each error handler

Based on the components in the scope, a list of possible errors





[NOTE]
If you want to have a handler set to *All*, make sure that you place it in the last position. Conditions are evaluated in order, so anything placed after "All" would never be evaluated.

=== Advanced Conditions


Instead of mapping an error type to an action, you can map them to more complex conditions


== Handling Transactions

A transaction is a series of actions that should never be partially executed, upon error actions should either be rolled back or committed.

The Try scope ignores transactions by default, but can be set to treat the components within it as a transaction.

* Ignore (default)
+
Actions aren't treated as a transaction, errors cause no rollbacks or commits.


You can set the Transactional Action to *Always Begin*, which means that a new transaction is started every time the scope is executed. In some cases where execution order may vary (due to asynchronous actions happening in parallel), you can set the Transactional Action to *Begin or Join*. With this option selected, a new transaction is started only if there are none already affecting the stream of execution.

=======
== Different Errors

You can set different paths to be executed depending on the error type.

== Handling Transactions

A transaction is a series of actions that should never be partially executed, upon error actions should either be rolled back or committed.

The Try scope ignores transactions by default, but you can configure it so that actions within it are treated as a transaction.

You can set it to *Always Begin*, which means that a new transaction is started every time the scope is executed. In some cases where execution order may vary (due to asynchronous actions happening in parallel), you can set it to *Begin or Join*. With this option selected, a new transaction is started only if there are none already affecting the stream of execution. 




== Behavior Upon Fail

Propagate vs continue


Propagate: If an error occurs within the try scope, execution continues directly outside the next element in the flow

Continue: If an error occurs within the try scope, the entire flow breaks execution. If the try scope is nested within another try scope,
>>>>>>> Stashed changes





<<<<<<< Updated upstream
=======
== Advanced Conditions
>>>>>>> Stashed changes


== See Also
