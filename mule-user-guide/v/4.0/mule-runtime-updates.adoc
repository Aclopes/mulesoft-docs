= Mule Runtime v4.0 Updates
:keywords: news, updates, mule ESB, mule runtime, 4.0, Mule 4.0, Mule 4.0 for mule 3 developers, what's new Mule 4

Mule 4.0 introduces significant changes from previous versions. +
Its simplified language and reduced management complexity allows you to speed up the on ramping process and deliver applications faster.

If you are familiar with the concepts of the previous versions of the runtime, check the sections below to learn what's changing in Mule Runtime v4.0:


== Intelligent Self-Tuning Runtime

As opposed to Mule 3.x, Mule 4.0 is an entirely self-tuning and non-blocking runtime, meaning that it uses a task-oriented execution model allowing you to take advantage of non-blocking IO calls and avoiding performance problems due to incorrect processing strategy configurations. Mule 4.0 removes complex tuning requirements to achieve optimum performance.

Each Mule event process can now inform the runtime if it is a CPU intensive, CPU light, or IO intensive operation. This allows the Mule Runtime to self-tune for different workloads dynamically, so you don't have to manually manage thread pools.

== Module Consistency

Mule 4.0 introduces more consistency around connectors and extensions unifying everything as modules to extend the behavior inside a Mule application.

Both custom and core connectors are created and managed using the Mule SDK, allowing the user a unified connector/module experience.

// COMBAK: Smart connectors are not going to be available for BETA
// Introducing Smart Connectors: Modules designed using XML to manipulate connections. +
// Users can define the module, set configurations and define operations that can later be invoked in the mule application to manipulate connections.

// REVIEW: Need confirmation about private flows going away.

== Simplified Message Structure and Scopes

Mule 4.0 includes a simplified Mule Message composed by a payload and its metadata. +
The Mule message is now part of an entire contextual information known as the Mule Event.

All other concepts around the former Mule Event object have been deprecated. Meaning that there are no more _inbound_ nor _outbound_ properties, and all information around the Mule event is now exposed through variables, allowing the user to completely manage the Mule event.

Everything contained within a Mule application is a component. +
Components that act on a Mule Event are event processors, and every processor that defines an operation to apply to the Mule event are known as operations.

//TODO Double check this example

[source,XML,linenums]
----
<httpn:request config-ref="requestConfig" method="#[dw:attributes.method]" path="#[dw:attributes.requestPath]" parseResponse="false">
       <httpn:request-builder>
           <httpn:query-params>#[dw:attributes.queryParams]</httpn:query-params>
           <httpn:headers>#[dw:attributes.headers]</httpn:headers>
       </httpn:request-builder>
</httpn:request>
----

Once an operation executes, the result is a new message, replacing the message in the Mule event.

It is also possible to define a _target_ to save the new Mule message in a Variable:

[source,XML,linenums]
----
<httpn:request target="myVar" config-ref="requestConfig" method="#[dw:attributes.method]" path="#[dw:attributes.requestPath]" parseResponse="false">
      <httpn:request-builder>
          <httpn:query-params>#[dw:attributes.queryParams]</httpn:query-params>
          <httpn:headers>#[dw:attributes.headers]</httpn:headers>
      </httpn:request-builder>
</httpn:request>
----
This saves the Mule message in the `myVar` variable to be accessed later.


== New Error Handling Strategies


Mule 4.0 moves away from the Exception scenario, and introduces a series of scopes to handle errors in your flow.

//REVIEW: Present this in a better way.
* The try scope grants you a specific error handling for the  event processors enclosed in this scope.
* The on-error scope lets you define an error type and an expression to match it order to execute the event processors within it.
* The error-handler scope replaces all exception strategies in Mule 3.x. This scope can contain other inner on-error scopes.


== Mule API

Mule 4.0 includes new, well defined APIs. These make it easier to extend Mule and provide clarity to developers on what the proper extension points are.

The runtime exposes 3 main APIs that allow you to build on top and extend the runtime capabilities:

* Core API: Mule message
* Extensions API: APIs which allow users to create modules, message processors, transformers, etc. which extend the runtime.
* Tooling API: All DataSense metadata and propagation is now part of the runtime, and can be accessed as part of the tooling API, which is bundled with the Mule Agent.

== Classloader Isolation

Mule 4.0 loads each Module in its own classloader, isolating the modules from internal Mule code. +
Given that applications are no longer dependent from internal Mule changes, users are able to upgrade their runtime version without breaking compatibility with other modules.

All modules are distributed outside the runtime, meaning that Mule 4.0 does not include any _connector_ by default.

== DataWeave 2.0: The Mule Expression Language

[CAUTION]
MEL is being deprecated, and Dataweave is now the default expression language within the runtime.

DataWeave 2.0 improves with the following features:

* Language simplifications - everything is now a function!
* DataWeave scripts can now be packaged and reused, via the new imports and modules features. This replaces the transformers from Mule 3.x.

[NOTE]
Some operations are not available outside EE. +
A community version of DataWeave is shipped with the Mule Kernel.

== Compatibility Module

To help you migrate to Mule 4.0, we included a Compatibility Module with a migration tool for the new semantics.
