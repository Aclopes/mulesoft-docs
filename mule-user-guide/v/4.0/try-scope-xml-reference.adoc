= About Try Scope

A Try scope follows the structure described below.


* A single root element `<try>`

* Components that are executed under the error-handling rules defined by
the Try scope are defined as child elements of the `try` element.

* A single `<error-handler>` element holds all error handling strategies for the scope.

* In the error handler, one or serveral `on-error-continue`  `on-error-propagate` and `on-error-retry` define the various strategies.

* Components that are executed when a matching error occurs are defined as child elements of the `on-error` element.


Each on-error element has a list of one or several error types that trigger it


[NOTE]
Note that conditions are evaluated in order. If a path is set to *All*, it must always be the last.


As an alternative to mapping a path to a set of error types, you can map it to a freely defined condition. For example, you can map a path to a condition like this:

`when error.cause.message.contains(“fatal”)`


== Handling Transactions

A transaction is a series of actions that should never be partially executed, errors should lead to either a rollback or a commit.

The Try scope can be set to treat the components within it as a transaction. It can be configured in the following ways:

* *Ignore* (default)
+
Actions aren't treated as a transaction, errors cause no rollbacks or commits.

* *Always Begin*
+
A new transaction is started every time the scope is executed.

* *Begin or Join*
+
Only relevant in cases where execution order may vary (for example due to asynchronous actions happening outside the flow). If the current processing of the flow has already begun a transaction, join it. Otherwise, begin a new one.


== Custom Error Types


In each Try scope, you can map standard error types to a custom error type. When using multiple Try scopes, you can use these custom error types to differentiate similar errors that may occur in different parts of the flow. For example, if your flow has two HTTP Request connectors that reach out to different REST services, a connectivity error on either produces the same error message. By wrapping each in a different Try scope and setting custom error types, you can differentiate them.




== See Also
