= Key Concepts
:keywords: studio, server, components, connectors, elements, big picture, architecture

Mule works by responding to _events_ initiated by external resources.

At the simplest level, Mule applications accept and process events as *Mule Events* through several operations.

The *Mule Event* represents the _context of information_ of the event that triggers the Mule application's logic. +
The *Mule event* travels through the *Flow* containing a *Mule Message* composed by:

* A *payload* with the main data that the mule application processes.
* A collection of *Attributes* with metadata about the message's payload.

And *Variables*, which are pieces of information about the *Mule Event* meant to be used by the application that is processing it.

[NOTE]
Alternatively, large or streaming messages can be processed as *records* in a *batch job*.

// TODO: Would it make sense to show Event Context (ExecutionContext) ?
// === Event Context
//The ExecutionContext that does not change within the scope of a single request and has the orginalPayload, MEP, credentials as well as reference to txContext and muleContext.

contain multiple linked flows and/or batch jobs, which, in combination, perform the integration required for your use case.

== Flows

// TODO: Review Flow.
A flow is the construct within which you link together several individual elements to handle the receipt, processing, and eventual routing of a message. You can connect many flows together to build a complete application which you can then deploy on premise, on Mule or another application server, or in the cloud. 

// TODO: review message processor renaming to Operation
At the simplest level, flows are sequences of _operation_. A *Mule Event* that enters a flow may pass through a wide variety of processors.

// TODO: review building blocks renaming to Components
The units that make up flows may be referred to as *Components* (in Studio's graphical representation of a flow) or elements (in an XML flow representation). +

// TODO: Review studio pallets containing only operations as opposed to building blocks.
// In general, a building block corresponds to an icon in the Anypoint Studio GUI, which in turn represents a message source, processor, _or_ component. A building block is a visual representation of an XML element within the Mule application's XML configuration file.

// TODO: Review the idea of adding message sources as a key concept
// == Message Sources
//
// Mule processes *messages*, also known as *events*, which may be transmitted from resources external to Mule. For example, a message can be initiated by an event such as a consumer request from a mobile device, or a change to data in a database, or the creation of a new customer ID in a SaaS application.
//
// The first building block of most flows or batch jobs is a receiver which receives new messages and places them in the queue for processing. This *message source* – in the example above, an inbound HTTP endpoint – receives messages from one or more external sources, thus triggering the execution of a flow or batch job. Message sources in Mule are usually Anypoint Connectors, elements which provide connectivity to a specific external source, either via a standard protocol (such as HTTP, FTP, SMTP) or a third-party API (such as Salesforce.com, Twitter, or MongoDB.)

// TODO: Review Message Processors
// == Message Processors
//
// In Mule, message processors are grouped together by category.
//
// Mule *transformers* are the key to exchanging data between nodes, as they allow Mule to convert message payload data to a format that another application can understand. Mule also enables content enrichment of messages which allows you to retrieve additional data during processing and attach it to the message.
//
// Mule uses *components* to conduct backend processes for specific business logic such as checking customer and inventory databases. Components route messages to the correct application, such as an order fulfillment system. Mule uses link:http://en.wikipedia.org/wiki/Staged_event-driven_architecture[Staged Event-Driven Architecture (SEDA)] for core asynchronous message processing in flows. Importantly, components don't have to have any Mule-specific code; they can simply be POJOs, Spring beans, Java beans, Groovy scripts, or web services containing the business logic for processing data. Components can even be developed in other languages such as Python, JavaScript, Ruby, and PHP. Mule’s catalog of building blocks support the most commonly used Enterprise Integration Patterns.
//
// Flows and batch jobs can also include *filters*, *scopes*, and *routers*. For example, you can use a filter to whitelist IP addresses from which your application accepts messages; you can use a scope to "wrap" around several message processors and cache the result of the processing they perform; you can use a router to send messages down different paths in your application depending on the content of the message payload. Mule includes a variety of filters, scopes, and routers to customize how a flow or batch job processes messages.
//

== DataWeave

Dataweave is the primary language used for formulating expressions in Mule, allowing you to access, manipulate, and use information from the message and its environment. 

At runtime, Mule evaluates expressions while executing a flow to:

* Extract information that it can use to process the current message.
* Set or manipulate a value in the message header or payload.
* Perform an operation on information in the message, application, Mule instance, or server.
